(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{214:function(t,_,v){"use strict";v.r(_);var e=v(0),r=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("存储结构")]),t._v(" "),v("p",[t._v("物理结构：顺序存储结构（数组），链式存储结构（链表）")]),t._v(" "),v("p",[t._v("逻辑结构：线性结构（栈、队列、哈希表），非线性结构（树、图）")])]),t._v(" "),v("h2",{attrs:{id:"数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),v("blockquote",[v("p",[t._v("数组是一种线性表数据结构，它用一块「连续」的内存空间来存储数据。")]),t._v(" "),v("p",[t._v("存储方式是顺序存储")])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://time.geekbang.org/column/article/40961",target:"_blank",rel:"noopener noreferrer"}},[t._v("为什么很多编程语言中数组都从0开始编号？"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("最坏情况下的时间复杂度：")]),t._v(" "),v("ul",[v("li",[t._v("读取/修改 - O(1)")]),t._v(" "),v("li",[t._v("插入/删除 - O(n)")])]),t._v(" "),v("p",[t._v("因此，数组适合读操作多，写操作少的场景")]),t._v(" "),v("h2",{attrs:{id:"链表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),v("blockquote",[v("p",[t._v("和数组相反，链表并不需要一块连续的内存空间，它通过「指针」将一组零散的内存串联起来使用。")]),t._v(" "),v("p",[t._v("除了单向链表，还有双向链表、循环链表")]),t._v(" "),v("p",[t._v("存储方式是随机存储")])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://time.geekbang.org/column/article/41013",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何实现 LRU 缓存淘汰算法？"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("最坏情况下的时间复杂度：")]),t._v(" "),v("ul",[v("li",[t._v("插入/修改 - O(1)")]),t._v(" "),v("li",[t._v("读取/删除 - O(n)")])]),t._v(" "),v("p",[t._v("因此，链表适合写操作多，读操作少的场景")]),t._v(" "),v("h2",{attrs:{id:"栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),v("blockquote",[v("p",[t._v("栈是一种线性逻辑结构，遵循「先进后出」原则（可以想象一下羽毛球桶）。最先存入的元素叫做「栈底」，最后存入的就是「栈顶」。")]),t._v(" "),v("p",[t._v("存储方式可以是数组，也可以是链表")])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://time.geekbang.org/column/article/41222",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何实现浏览器的前进后退功能？"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("img",{attrs:{src:"http://ww1.sinaimg.cn/bmiddle/6af89bc8gw1f8ssby529lg20ak05wqbx.gif",alt:"栈"}})]),t._v(" "),v("p",[t._v("栈的基本操作是「入栈」和「出栈」。因为入栈和出栈都只会影响到最后一个元素，所以入栈和出栈的时间复杂度都是 O(1)")]),t._v(" "),v("p",[t._v("常见场景：")]),t._v(" "),v("ul",[v("li",[t._v("浏览器的前进后退功能")]),t._v(" "),v("li",[t._v("小程序的页面跳转")]),t._v(" "),v("li",[t._v("面包屑导航")])]),t._v(" "),v("h2",{attrs:{id:"队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),v("blockquote",[v("p",[t._v("队列也是一种线性逻辑结构，遵循「先入先出」原则（可以想象一下排队）。队列的出口端叫「队头」，入口端叫「队尾」。")]),t._v(" "),v("p",[t._v("存储方式可以是数组，也可以是链表")])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://time.geekbang.org/column/article/41330",target:"_blank",rel:"noopener noreferrer"}},[t._v("队列在线程池等有限资源池中的应用"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("队列的基本操作是「入队」和「出队」，和栈一样，入队和出队的时间复杂度也是 O(1)")]),t._v(" "),v("p",[t._v("常见场景：")]),t._v(" "),v("ul",[v("li",[t._v("多线程中争夺公平锁的等待队列")])]),t._v(" "),v("p",[t._v("变种：")]),t._v(" "),v("ul",[v("li",[t._v("双端队列 - 综合了栈和队列的优点，队头和队尾都可以入队出队")]),t._v(" "),v("li",[t._v("优先队列 - 遵循的不是先入先出，而是谁的优先级最高，谁先出队")])]),t._v(" "),v("h2",{attrs:{id:"散列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#散列表"}},[t._v("#")]),t._v(" 散列表")]),t._v(" "),v("blockquote",[v("p",[t._v("散列表又叫哈希表，是存储「key-value」映射的集合。它是基于数组实现的。")]),t._v(" "),v("p",[t._v("存储方式为数组")])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://time.geekbang.org/column/article/64233",target:"_blank",rel:"noopener noreferrer"}},[t._v("Word文档中的单词拼写检查功能是如何实现的？"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("只要给出一个 key，就可以高效地查找到它所匹配的 value。时间复杂度接近于 O(1)")]),t._v(" "),v("h2",{attrs:{id:"树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[t._v("#")]),t._v(" 树")]),t._v(" "),v("p",[t._v("树是 n(n>=0) 个节点的有限集。当 n=0 时，称为空树。在任意一个非空树中，有如下特点：")]),t._v(" "),v("ol",[v("li",[t._v("有且仅有一个特定的称为「根」的节点")]),t._v(" "),v("li",[t._v("当 n>1 时，其余节点可分为 m(m>0) 个互不相交的有限集，每一个集合本身又是一个树，并成为根的子树。")])]),t._v(" "),v("h3",{attrs:{id:"二叉树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),v("blockquote",[v("p",[t._v("二叉树是树的一种特殊形式。这种树的每个节点最多只能有两个子节点")]),t._v(" "),v("p",[t._v("二叉树还有两种特殊形式，一个是「满二叉树」，一个是「完全二叉树」")]),t._v(" "),v("p",[t._v("存储方式可以说数组或者链表")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/09/2b/09c2972d56eb0cf67e727deda0e9412b.jpg",alt:"二叉树"}})]),t._v(" "),v("h3",{attrs:{id:"深度优先遍历"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#深度优先遍历"}},[t._v("#")]),t._v(" 深度优先遍历")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("前序遍历")]),t._v(" "),v("p",[t._v("顺序为 根节点->左子树->右子树")])]),t._v(" "),v("li",[v("p",[t._v("中序遍历")]),t._v(" "),v("p",[t._v("顺序为 左子树->根节点->右子树")])]),t._v(" "),v("li",[v("p",[t._v("后序遍历")]),t._v(" "),v("p",[t._v("顺序为 左子树->右子树->根节点")])])]),t._v(" "),v("h3",{attrs:{id:"广度优先遍历"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#广度优先遍历"}},[t._v("#")]),t._v(" 广度优先遍历")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("层序遍历")]),t._v(" "),v("p",[t._v("顾名思义，一层一层横向遍历各个节点")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);